from functions import *
from model import Autoencoder
import torch
from torch.utils.data import DataLoader
from torchvision import transforms


# Hyper parameter
path = 'wafer.zip'
weights_path = './weights/model.pth'
batch_size = 1
num_gen = 5   # Number of generated image

# Data preprocessing
# Data augmentation
data_transforms = transforms.Compose([transforms.ToTensor()])
# Load data
train_data = wafer_dataset(transform=data_transforms, folder_path=path, test_gen=False)
# Set data loader
train_data_loader = DataLoader(dataset=train_data, batch_size=batch_size, shuffle=False)


# Initialize model
model = Autoencoder()
try:
    print("Load weights...")
    model.load_weights(weights_path)
    print('Load weights Successful!')
except FileNotFoundError:
    print('Weights file not found!')
    print('Start with new model')

# Set training device
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")


# Generate step
def generate(plot_imgs=False):
    model.to(device)
    model.eval()
    gen_data = []
    gen_label = []
    classes = []
    print("Generate Data...")
    for _, (x, y) in enumerate(train_data_loader):
        class_name = train_data.classes[y[0].item()]
        truth_img = x.squeeze(0)
        x = x.to(device, dtype=torch.float)
        latent_vector = model.encoder(x)
        temp = []   # Temporary save the generated images.
        for i in range(num_gen):
            # Add the normal distribution to latent vector.
            noised_latent_vector = latent_vector + torch.normal(mean=0., std=0.1, size=latent_vector.size()).to(device)
            # Generate the image by from noised latent vector.
            gen_ims = model.decoder(noised_latent_vector)
            # Reduce the generated image dimension from (1, 3, 26, 26) to (3, 26, 26).
            gen_ims = gen_ims.squeeze(0)
            # Save the generated image for show step.
            temp.append(gen_ims.data)
            # Resize the generated image dimension from (3, 26, 26) to (26, 26, 3).
            gen_ims = gen_ims.permute(1, 2, 0)
            # Save the generated image and move it from cuda to cup, then convert to numpy data type.
            gen_data.append(gen_ims.data.cpu().numpy())
            # Save the label.
            gen_label.append([y])
        if plot_imgs:
            if class_name not in classes:
                # This step will show a class image that is generated by model.
                imshow(truth_img, temp, class_name=class_name)
                classes.append(class_name)
                temp.clear()
    print("Finish!")
    print("Save data to file")
    gen_data = np.array(gen_data)
    np.save('gen_data', gen_data)
    gen_label = np.array(gen_label)
    np.save('gen_label', gen_label)
    print("Finish")


if __name__ == '__main__':
    generate(plot_imgs=True)
